/*!
 * pixi-picture - v1.0.1
 * Compiled Thu Sep 08 2016 11:54:22 GMT+0200 (CEST)
 *
 * pixi-picture is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var r;r="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,(r.pixiPicture||(r.pixiPicture={})).min=e()}}(function(){return function e(r,t,n){function o(a,u){if(!t[a]){if(!r[a]){var s="function"==typeof require&&require;if(!u&&s)return s(a,!0);if(i)return i(a,!0);var c=new Error("Cannot find module '"+a+"'");throw c.code="MODULE_NOT_FOUND",c}var d=t[a]={exports:{}};r[a][0].call(d.exports,function(e){var t=r[a][1][e];return o(t?t:e)},d,d.exports,e,r,t,n)}return t[a].exports}for(var i="function"==typeof require&&require,a=0;a<n.length;a++)o(n[a]);return o}({1:[function(e,r,t){function n(e){PIXI.Shader.call(this,e,"#define GLSLIFY 1\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nuniform mat3 projectionMatrix;\nuniform mat3 mapMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vMapCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vMapCoord = (mapMatrix * vec3(aVertexPosition, 1.0)).xy;\n    vTextureCoord = aTextureCoord;\n}\n","#define GLSLIFY 1\nvarying vec2 vTextureCoord;\nvarying vec2 vMapCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler[2];\nuniform vec4 uTextureClamp;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec2 textureCoord = clamp(vTextureCoord, uTextureClamp.xy, uTextureClamp.zw);\n    vec4 source = texture2D(uSampler[0], textureCoord);\n    vec4 target = texture2D(uSampler[1], vMapCoord);\n\n    //reverse hardlight\n    //yeah, premultiplied\n    if (source.a == 0.0) {\n        gl_FragColor = vec4(0, 0, 0, 0);\n        return;\n    }\n    vec3 Cb = source.rgb/source.a, Cs;\n    if (target.a > 0.0) {\n        Cs = target.rgb / target.a;\n    }\n    vec3 multiply = Cb * Cs * 2.0;\n    vec3 Cs2 = Cs * 2.0 - 1.0;\n    vec3 screen = Cb + Cs2 - Cb * Cs2;\n    vec3 B;\n    if (Cb.r <= 0.5) {\n        B.r = multiply.r;\n    } else {\n        B.r = screen.r;\n    }\n    if (Cb.g <= 0.5) {\n        B.g = multiply.g;\n    } else {\n        B.g = screen.g;\n    }\n    if (Cb.b <= 0.5) {\n        B.b = multiply.b;\n    } else {\n        B.b = screen.b;\n    }\n    vec4 res;\n    res.xyz = (1.0 - source.a) * Cs + source.a * B;\n    res.a = source.a + target.a * (1.0-source.a);\n    gl_FragColor = vec4(res.xyz * res.a, res.a);\n}\n"),this.bind(),this.uniforms.uSampler=[0,1]}n.prototype=Object.create(PIXI.Shader.prototype),n.prototype.constructor=n,r.exports=n},{}],2:[function(e,r,t){function n(e){PIXI.Shader.call(this,e,"#define GLSLIFY 1\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nuniform mat3 projectionMatrix;\nuniform mat3 mapMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vMapCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vMapCoord = (mapMatrix * vec3(aVertexPosition, 1.0)).xy;\n    vTextureCoord = aTextureCoord;\n}\n","#define GLSLIFY 1\nvarying vec2 vTextureCoord;\nvarying vec2 vMapCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler[2];\nuniform vec4 uTextureClamp;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec2 textureCoord = clamp(vTextureCoord, uTextureClamp.xy, uTextureClamp.zw);\n    vec4 source = texture2D(uSampler[0], textureCoord);\n    vec4 target = texture2D(uSampler[1], vMapCoord);\n\n    //reverse hardlight\n    if (source.a == 0.0) {\n        gl_FragColor = vec4(0, 0, 0, 0);\n        return;\n    }\n    //yeah, premultiplied\n    vec3 Cb = source.rgb/source.a, Cs;\n    if (target.a > 0.0) {\n        Cs = target.rgb / target.a;\n    }\n    vec3 multiply = Cb * Cs * 2.0;\n    vec3 Cb2 = Cb * 2.0 - 1.0;\n    vec3 screen = Cb2 + Cs - Cb2 * Cs;\n    vec3 B;\n    if (Cs.r <= 0.5) {\n        B.r = multiply.r;\n    } else {\n        B.r = screen.r;\n    }\n    if (Cs.g <= 0.5) {\n        B.g = multiply.g;\n    } else {\n        B.g = screen.g;\n    }\n    if (Cs.b <= 0.5) {\n        B.b = multiply.b;\n    } else {\n        B.b = screen.b;\n    }\n    vec4 res;\n    res.xyz = (1.0 - source.a) * Cs + source.a * B;\n    res.a = source.a + target.a * (1.0-source.a);\n    gl_FragColor = vec4(res.xyz * res.a, res.a);\n}\n"),this.bind(),this.uniforms.uSampler=[0,1]}n.prototype=Object.create(PIXI.Shader.prototype),n.prototype.constructor=n,r.exports=n},{}],3:[function(e,r,t){function n(e){PIXI.ObjectRenderer.call(this,e)}function o(e){return e+=0===e,--e,e|=e>>>1,e|=e>>>2,e|=e>>>4,e|=e>>>8,e|=e>>>16,e+1}var i=e("./PictureShader"),a=e("./mapFilterBlendModesToPixi");PIXI.glCore;n.prototype=Object.create(PIXI.ObjectRenderer.prototype),n.prototype.constructor=n,n.prototype.onContextChange=function(){var e=this.renderer.gl;this.quad=new PIXI.Quad(e),this.normalShader=new i(e),this.drawModes=a(e),this.quad.initVao(this.normalShader),this._tempClamp=new Float32Array(4),this._tempColor=new Float32Array(4),this._tempRect=new PIXI.Rectangle,this._tempRect2=new PIXI.Rectangle,this._tempRect3=new PIXI.Rectangle,this._tempMatrix=new PIXI.Matrix,this._bigBuf=new Uint8Array(1<<20),this._renderTexture=new PIXI.BaseRenderTexture(1024,1024)},n.prototype.start=function(){},n.prototype.flush=function(){},n.prototype._getRenderTexture=function(e,r){return(this._renderTexture.width<e||this._renderTexture.height<r)&&(r=o(e),r=o(r),this._renderTexture.resize(e,r)),this._renderTexture},n.prototype._getBuf=function(e){var r=this._bigBuf;return r.length<e&&(e=o(e),r=new Uint8Array(e),this._bigBuf=r),r},n.prototype.render=function(e){if(e.texture.valid){var r=this.drawModes[e.blendMode];r?this._renderBlend(e,r):this._renderNormal(e,this.normalShader)}},n.prototype._renderNormal=function(e,r){var t=this.renderer;t.bindShader(r),t.state.setBlendMode(e.blendMode),this._renderInner(e,r)},n.prototype._renderBlend=function(e,r){var t=this.renderer,n=e.getBounds(),o=t._activeRenderTarget,i=o.projectionMatrix,a=i.a<0,u=i.d<0,s=o.resolution,c=this._tempRect,d=o.sourceFrame||o.destinationFrame;c.x=0,c.y=0,c.width=d.width,c.height=d.height;var p=this._tempRect2,v=d.width*s,l=d.height*s;p.x=(n.x+i.tx/i.a)*s+v/2,p.y=(n.y+i.ty/i.d)*s+l/2,p.width=n.width*s,p.height=n.height*s,a&&(p.y=v-p.width-p.x),u&&(p.y=l-p.height-p.y);var h=(this._tempRect3,Math.floor(Math.max(c.x,p.x))),x=Math.ceil(Math.min(c.x+c.width,p.x+p.width)),m=Math.floor(Math.max(c.y,p.y)),f=Math.ceil(Math.min(c.y+c.height,p.y+p.height)),C=x-h,g=f-m;if(!(C<=0||g<=0)){var y=this._getRenderTexture(C,g);t.bindTexture(y,1);var b=t.gl;if(t.renderingToScreen&&o.root){this._getBuf(C*g*4);b.readPixels(h,m,C,g,b.RGBA,b.UNSIGNED_BYTE,this._bigBuf),b.texSubImage2D(b.TEXTURE_2D,0,0,0,C,g,b.RGBA,b.UNSIGNED_BYTE,this._bigBuf)}else b.copyTexSubImage2D(b.TEXTURE_2D,0,0,0,h,m,C,g);if(t.bindShader(r),t.state.setBlendMode(PIXI.BLEND_MODES.NORMAL),r.uniforms.mapMatrix){var I=this._tempMatrix;I.a=p.width/y.width/n.width,a?(I.a=-I.a,I.ty=(p.x-h)/y.width-(n.x+n.width)*I.a):I.tx=(p.x-h)/y.width-n.x*I.a,I.d=p.height/y.height/n.height,u?(I.d=-I.d,I.ty=(p.y-m)/y.height-(n.y+n.height)*I.d):I.ty=(p.y-m)/y.height-n.y*I.d,r.uniforms.mapMatrix=I.toArray(!0,r.uniforms.mapMatrix)}this._renderInner(e,r)}},n.prototype._renderInner=function(e,r){for(var t=this.renderer,n=this.quad,o=e.texture._uvs,i=(n.vertices,e.computedGeometry?e.computedGeometry.vertices:e.vertexData),a=0;a<8;a++)n.vertices[a]=i[a];n.uvs[0]=o.x0,n.uvs[1]=o.y0,n.uvs[2]=o.x1,n.uvs[3]=o.y1,n.uvs[4]=o.x2,n.uvs[5]=o.y2,n.uvs[6]=o.x3,n.uvs[7]=o.y3,n.upload();var u=e.texture.frame,s=e.texture.baseTexture,c=this._tempClamp;c[0]=u.x/s.width+.5/s.realWidth,c[1]=u.y/s.height+.5/s.realWidth,c[2]=(u.x+u.width)/s.width-.5/s.realWidth,c[3]=(u.y+u.height)/s.height-.5/s.realWidth,r.uniforms.uTextureClamp=c;var d=this._tempColor;PIXI.utils.hex2rgb(e.tint,d);var p=e.worldAlpha;d[0]*=p,d[1]*=p,d[2]*=p,d[3]=p,r.uniforms.uColor=d,t.bindTexture(s,0),n.draw()},PIXI.WebGLRenderer.registerPlugin("picture",n),r.exports=n},{"./PictureShader":4,"./mapFilterBlendModesToPixi":7}],4:[function(e,r,t){function n(e){PIXI.Shader.call(this,e,"#define GLSLIFY 1\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}\n","#define GLSLIFY 1\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\nuniform vec4 uTextureClamp;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec2 textureCoord = clamp(vTextureCoord, uTextureClamp.xy, uTextureClamp.zw);\n    vec4 sample = texture2D(uSampler, textureCoord);\n    gl_FragColor = sample * uColor;\n}\n"),this.bind(),this.uniforms.uColor=new Float32Array(1,1,1,1)}n.prototype=Object.create(PIXI.Shader.prototype),n.prototype.constructor=n,r.exports=n},{}],5:[function(e,r,t){function n(e){PIXI.Sprite.call(this,e)}n.prototype=Object.create(PIXI.Sprite.prototype),n.prototype.constructor=n,r.exports=n,n.prototype._renderWebGL=function(e){this.updateGeometry&&this.updateGeometry(),e.setObjectRenderer(e.plugins.picture),e.plugins.picture.render(this)}},{}],6:[function(e,r,t){function n(e){PIXI.Shader.call(this,e,"#define GLSLIFY 1\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nuniform mat3 projectionMatrix;\nuniform mat3 mapMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vMapCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vMapCoord = (mapMatrix * vec3(aVertexPosition, 1.0)).xy;\n    vTextureCoord = aTextureCoord;\n}\n","#define GLSLIFY 1\nvarying vec2 vTextureCoord;\nvarying vec2 vMapCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler[2];\nuniform vec4 uTextureClamp;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec2 textureCoord = clamp(vTextureCoord, uTextureClamp.xy, uTextureClamp.zw);\n    vec4 source = texture2D(uSampler[0], textureCoord);\n    vec4 target = texture2D(uSampler[1], vMapCoord);\n\n    vec3 multiply = Cb * Cs * 2.0 + Cs * Cs * (1.0 - 2.0 * Cb);\n    vec3 screen = sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend);\n    vec3 B;\n\n    if (Cb.r <= 0.5) {\n        B.r = multiply.r;\n    } else {\n        B.r = screen.r;\n    }\n    if (Cb.g <= 0.5) {\n        B.g = multiply.g;\n    } else {\n        B.g = screen.g;\n    }\n    if (Cb.b <= 0.5) {\n        B.b = multiply.b;\n    } else {\n        B.b = screen.b;\n    }\n\n    vec4 res;\n\n    res.xyz = (1.0 - source.a) * Cs + source.a * B;\n    res.a = source.a + target.a * (1.0-source.a);\n    gl_FragColor = vec4(res.xyz * res.a, res.a);\n}\n"),this.bind(),this.uniforms.uSampler=[0,1]}n.prototype=Object.create(PIXI.Shader.prototype),n.prototype.constructor=n,r.exports=n},{}],7:[function(e,r,t){function n(e,r){return r=r||[],r[o.BLEND_MODES.OVERLAY]=new i(e),r[o.BLEND_MODES.HARD_LIGHT]=new a(e),r[o.BLEND_MODES.SOFT_LIGHT]=new SoftLightShader(e),r}var o=PIXI,i=e("./OverlayShader"),a=e("./HardLightShader");SoftLightShader=e("./SoftLightShader"),r.exports=n},{"./HardLightShader":1,"./OverlayShader":2,"./SoftLightShader":6}],8:[function(e,r,t){var n={PictureSprite:e("./PictureSprite"),PictureRenderer:e("./PictureRenderer")};Object.assign(PIXI.extras,n),r.exports=n},{"./PictureRenderer":3,"./PictureSprite":5}]},{},[8])(8)});
//# sourceMappingURL=pixi-picture.min.js.map
