{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/HardLightShader.js","src/OverlayShader.js","src/PictureRenderer.js","src/PictureShader.js","src/PictureSprite.js","src/SoftLightShader.js","src/mapFilterBlendModesToPixi.js","src"],"names":["f","exports","module","define","amd","g","window","global","self","this","pixiPicture","min","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","HardLightShader","gl","PIXI","Shader","bind","uniforms","uSampler","prototype","Object","create","constructor","OverlayShader","PictureRenderer","renderer","ObjectRenderer","nextPow2","v","PictureShader","mapFilterBlendModesToPixi","glCore","onContextChange","quad","Quad","normalShader","drawModes","initVao","_tempClamp","Float32Array","_tempColor","_tempRect","Rectangle","_tempRect2","_tempRect3","_tempMatrix","Matrix","_bigBuf","Uint8Array","_renderTexture","BaseRenderTexture","start","flush","_getRenderTexture","minWidth","minHeight","width","height","resize","_getBuf","size","buf","render","sprite","texture","valid","blendShader","blendMode","_renderBlend","_renderNormal","shader","bindShader","state","setBlendMode","_renderInner","spriteBounds","getBounds","renderTarget","_activeRenderTarget","matrix","projectionMatrix","flipX","flipY","d","resolution","screen","fr","sourceFrame","destinationFrame","x","y","bounds","fbw","fbh","tx","ty","x_1","Math","floor","max","x_2","ceil","y_1","y_2","pixelsWidth","pixelsHeight","rt","bindTexture","renderingToScreen","root","readPixels","RGBA","UNSIGNED_BYTE","texSubImage2D","TEXTURE_2D","copyTexSubImage2D","BLEND_MODES","NORMAL","mapMatrix","toArray","uvs","_uvs","vd","vertices","computedGeometry","vertexData","x0","y0","x1","y1","x2","y2","x3","y3","upload","frame","base","baseTexture","clamp","realWidth","uTextureClamp","color","utils","hex2rgb","tint","alpha","worldAlpha","uColor","draw","WebGLRenderer","registerPlugin","PictureSprite","Sprite","_renderWebGL","updateGeometry","setObjectRenderer","plugins","picture","SoftLightShader","array","CONST","OVERLAY","HARD_LIGHT","SOFT_LIGHT","myPlugin","assign","extras"],"mappings":"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","file":"pixi-picture.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","\n\n/**\n * @class\n * @extends PIXI.Shader\n * @memberof PIXI.tilemap\n * @param gl {PIXI.Shader} The WebGL shader manager this shader works for.\n */\nfunction HardLightShader(gl)\n{\n    PIXI.Shader.call(this,\n        gl,\n        \"#define GLSLIFY 1\\nattribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\nattribute vec4 aColor;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 mapMatrix;\\n\\nvarying vec2 vTextureCoord;\\nvarying vec2 vMapCoord;\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n    vMapCoord = (mapMatrix * vec3(aVertexPosition, 1.0)).xy;\\n    vTextureCoord = aTextureCoord;\\n}\\n\",\n        \"#define GLSLIFY 1\\nvarying vec2 vTextureCoord;\\nvarying vec2 vMapCoord;\\nvarying vec4 vColor;\\n\\nuniform sampler2D uSampler[2];\\nuniform vec4 uTextureClamp;\\nuniform vec4 uColor;\\n\\nvoid main(void)\\n{\\n    vec2 textureCoord = clamp(vTextureCoord, uTextureClamp.xy, uTextureClamp.zw);\\n    vec4 source = texture2D(uSampler[0], textureCoord);\\n    vec4 target = texture2D(uSampler[1], vMapCoord);\\n\\n    //reverse hardlight\\n    //yeah, premultiplied\\n    if (source.a == 0.0) {\\n        gl_FragColor = vec4(0, 0, 0, 0);\\n        return;\\n    }\\n    vec3 Cb = source.rgb/source.a, Cs;\\n    if (target.a > 0.0) {\\n        Cs = target.rgb / target.a;\\n    }\\n    vec3 multiply = Cb * Cs * 2.0;\\n    vec3 Cs2 = Cs * 2.0 - 1.0;\\n    vec3 screen = Cb + Cs2 - Cb * Cs2;\\n    vec3 B;\\n    if (Cb.r <= 0.5) {\\n        B.r = multiply.r;\\n    } else {\\n        B.r = screen.r;\\n    }\\n    if (Cb.g <= 0.5) {\\n        B.g = multiply.g;\\n    } else {\\n        B.g = screen.g;\\n    }\\n    if (Cb.b <= 0.5) {\\n        B.b = multiply.b;\\n    } else {\\n        B.b = screen.b;\\n    }\\n    vec4 res;\\n    res.xyz = (1.0 - source.a) * Cs + source.a * B;\\n    res.a = source.a + target.a * (1.0-source.a);\\n    gl_FragColor = vec4(res.xyz * res.a, res.a);\\n}\\n\"\n    );\n    this.bind();\n    this.uniforms.uSampler = [0, 1];\n}\n\nHardLightShader.prototype = Object.create(PIXI.Shader.prototype);\nHardLightShader.prototype.constructor = HardLightShader;\nmodule.exports = HardLightShader;\n","\n\n/**\n * @class\n * @extends PIXI.Shader\n * @memberof PIXI.tilemap\n * @param gl {PIXI.Shader} The WebGL shader manager this shader works for.\n */\nfunction OverlayShader(gl)\n{\n    PIXI.Shader.call(this,\n        gl,\n        \"#define GLSLIFY 1\\nattribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\nattribute vec4 aColor;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 mapMatrix;\\n\\nvarying vec2 vTextureCoord;\\nvarying vec2 vMapCoord;\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n    vMapCoord = (mapMatrix * vec3(aVertexPosition, 1.0)).xy;\\n    vTextureCoord = aTextureCoord;\\n}\\n\",\n        \"#define GLSLIFY 1\\nvarying vec2 vTextureCoord;\\nvarying vec2 vMapCoord;\\nvarying vec4 vColor;\\n\\nuniform sampler2D uSampler[2];\\nuniform vec4 uTextureClamp;\\nuniform vec4 uColor;\\n\\nvoid main(void)\\n{\\n    vec2 textureCoord = clamp(vTextureCoord, uTextureClamp.xy, uTextureClamp.zw);\\n    vec4 source = texture2D(uSampler[0], textureCoord);\\n    vec4 target = texture2D(uSampler[1], vMapCoord);\\n\\n    //reverse hardlight\\n    if (source.a == 0.0) {\\n        gl_FragColor = vec4(0, 0, 0, 0);\\n        return;\\n    }\\n    //yeah, premultiplied\\n    vec3 Cb = source.rgb/source.a, Cs;\\n    if (target.a > 0.0) {\\n        Cs = target.rgb / target.a;\\n    }\\n    vec3 multiply = Cb * Cs * 2.0;\\n    vec3 Cb2 = Cb * 2.0 - 1.0;\\n    vec3 screen = Cb2 + Cs - Cb2 * Cs;\\n    vec3 B;\\n    if (Cs.r <= 0.5) {\\n        B.r = multiply.r;\\n    } else {\\n        B.r = screen.r;\\n    }\\n    if (Cs.g <= 0.5) {\\n        B.g = multiply.g;\\n    } else {\\n        B.g = screen.g;\\n    }\\n    if (Cs.b <= 0.5) {\\n        B.b = multiply.b;\\n    } else {\\n        B.b = screen.b;\\n    }\\n    vec4 res;\\n    res.xyz = (1.0 - source.a) * Cs + source.a * B;\\n    res.a = source.a + target.a * (1.0-source.a);\\n    gl_FragColor = vec4(res.xyz * res.a, res.a);\\n}\\n\"\n    );\n    this.bind();\n    this.uniforms.uSampler = [0, 1];\n}\n\nOverlayShader.prototype = Object.create(PIXI.Shader.prototype);\nOverlayShader.prototype.constructor = OverlayShader;\nmodule.exports = OverlayShader;\n","var PictureShader = require('./PictureShader'),\n    mapFilterBlendModesToPixi = require('./mapFilterBlendModesToPixi'),\n    glCore = PIXI.glCore;\n\n/**\n * Renderer that clamps the texture so neighbour frames wont bleed on it\n * immitates context2d drawImage behaviour\n *\n * @class\n * @memberof PIXI.extras\n * @extends PIXI.ObjectRenderer\n * @param renderer {PIXI.WebGLRenderer} The renderer this plugin works for\n */\nfunction PictureRenderer(renderer) {\n    PIXI.ObjectRenderer.call(this, renderer);\n}\n\nPictureRenderer.prototype = Object.create(PIXI.ObjectRenderer.prototype);\nPictureRenderer.prototype.constructor = PictureRenderer;\n\nPictureRenderer.prototype.onContextChange = function () {\n    var gl = this.renderer.gl;\n    this.quad = new PIXI.Quad(gl);\n    this.normalShader = new PictureShader(gl);\n    this.drawModes = mapFilterBlendModesToPixi(gl);\n    this.quad.initVao(this.normalShader);\n    this._tempClamp = new Float32Array(4);\n    this._tempColor = new Float32Array(4);\n    this._tempRect = new PIXI.Rectangle();\n    this._tempRect2 = new PIXI.Rectangle();\n    this._tempRect3 = new PIXI.Rectangle();\n    this._tempMatrix = new PIXI.Matrix();\n    this._bigBuf = new Uint8Array(1 << 20);\n    this._renderTexture = new PIXI.BaseRenderTexture(1024, 1024);\n};\n\nPictureRenderer.prototype.start = function () {\n    //noop\n};\n\nPictureRenderer.prototype.flush = function () {\n    //noop\n};\n\nfunction nextPow2(v) {\n    v += v === 0;\n    --v;\n    v |= v >>> 1;\n    v |= v >>> 2;\n    v |= v >>> 4;\n    v |= v >>> 8;\n    v |= v >>> 16;\n    return v + 1;\n}\n\nPictureRenderer.prototype._getRenderTexture = function (minWidth, minHeight) {\n    if (this._renderTexture.width < minWidth ||\n        this._renderTexture.height < minHeight) {\n        minHeight = nextPow2(minWidth);\n        minHeight = nextPow2(minHeight);\n        this._renderTexture.resize(minWidth, minHeight);\n    }\n    return this._renderTexture;\n};\n\nPictureRenderer.prototype._getBuf = function (size) {\n    var buf = this._bigBuf;\n    if (buf.length < size) {\n        size = nextPow2(size);\n        buf = new Uint8Array(size);\n        this._bigBuf = buf;\n    }\n    return buf;\n};\n\n/**\n * Renders the picture object.\n *\n * @param sprite {PIXI.tilemap.PictureSprite} the picture to render\n */\nPictureRenderer.prototype.render = function (sprite) {\n    if (!sprite.texture.valid) {\n        return;\n    }\n    var blendShader = this.drawModes[sprite.blendMode];\n    if (blendShader) {\n        this._renderBlend(sprite, blendShader);\n    } else {\n        this._renderNormal(sprite, this.normalShader);\n    }\n};\n\nPictureRenderer.prototype._renderNormal = function (sprite, shader) {\n    var renderer = this.renderer;\n    renderer.bindShader(shader);\n    renderer.state.setBlendMode(sprite.blendMode);\n    this._renderInner(sprite, shader);\n};\n\nPictureRenderer.prototype._renderBlend = function (sprite, shader) {\n    //nothing there yet\n    var renderer = this.renderer;\n    var spriteBounds = sprite.getBounds();\n    var renderTarget = renderer._activeRenderTarget;\n    var matrix = renderTarget.projectionMatrix;\n    var flipX = matrix.a < 0;\n    var flipY = matrix.d < 0;\n    var resolution = renderTarget.resolution;\n    var screen = this._tempRect;\n    var fr = renderTarget.sourceFrame || renderTarget.destinationFrame;\n    screen.x = 0;\n    screen.y = 0;\n    screen.width = fr.width;\n    screen.height = fr.height;\n\n    var bounds = this._tempRect2;\n    var fbw = fr.width * resolution, fbh = fr.height * resolution;\n    bounds.x = (spriteBounds.x + matrix.tx / matrix.a) * resolution + fbw / 2;\n    bounds.y = (spriteBounds.y + matrix.ty / matrix.d) * resolution + fbh / 2;\n    bounds.width = spriteBounds.width * resolution;\n    bounds.height = spriteBounds.height * resolution;\n    if (flipX) {\n        bounds.y = fbw - bounds.width - bounds.x;\n    }\n    if (flipY) {\n        bounds.y = fbh - bounds.height - bounds.y;\n    }\n\n    var screenBounds = this._tempRect3;\n    var x_1 = Math.floor(Math.max(screen.x, bounds.x));\n    var x_2 = Math.ceil(Math.min(screen.x + screen.width, bounds.x + bounds.width));\n    var y_1 = Math.floor(Math.max(screen.y, bounds.y));\n    var y_2 = Math.ceil(Math.min(screen.y + screen.height, bounds.y + bounds.height));\n    var pixelsWidth = x_2 - x_1;\n    var pixelsHeight = y_2 - y_1;\n    if (pixelsWidth <= 0 || pixelsHeight <= 0) {\n        //culling\n        return;\n    }\n    //TODO: padding\n    var rt = this._getRenderTexture(pixelsWidth, pixelsHeight);\n    renderer.bindTexture(rt, 1);\n    var gl = renderer.gl;\n    if (renderer.renderingToScreen && renderTarget.root) {\n        var buf = this._getBuf(pixelsWidth * pixelsHeight * 4);\n        gl.readPixels(x_1, y_1, pixelsWidth, pixelsHeight, gl.RGBA, gl.UNSIGNED_BYTE, this._bigBuf);\n        //REVERT Y?\n        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, pixelsWidth, pixelsHeight, gl.RGBA, gl.UNSIGNED_BYTE, this._bigBuf);\n    } else {\n        gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, x_1, y_1, pixelsWidth, pixelsHeight);\n    }\n\n    renderer.bindShader(shader);\n    renderer.state.setBlendMode(PIXI.BLEND_MODES.NORMAL);\n    if (shader.uniforms.mapMatrix) {\n        var mapMatrix = this._tempMatrix;\n        mapMatrix.a = bounds.width / rt.width / spriteBounds.width;\n        if (flipX) {\n            mapMatrix.a = -mapMatrix.a;\n            mapMatrix.ty = (bounds.x - x_1) / rt.width - (spriteBounds.x + spriteBounds.width) * mapMatrix.a;\n        } else {\n            mapMatrix.tx = (bounds.x - x_1) / rt.width - spriteBounds.x * mapMatrix.a;\n        }\n        mapMatrix.d = bounds.height / rt.height / spriteBounds.height;\n        if (flipY) {\n            mapMatrix.d = -mapMatrix.d;\n            mapMatrix.ty = (bounds.y - y_1) / rt.height - (spriteBounds.y + spriteBounds.height) * mapMatrix.d;\n        } else {\n            mapMatrix.ty = (bounds.y - y_1) / rt.height - spriteBounds.y * mapMatrix.d;\n        }\n\n        shader.uniforms.mapMatrix = mapMatrix.toArray(true, shader.uniforms.mapMatrix);\n    }\n\n    this._renderInner(sprite, shader);\n};\n\n\nPictureRenderer.prototype._renderInner = function (sprite, shader) {\n    var renderer = this.renderer;\n    var quad = this.quad;\n    var uvs = sprite.texture._uvs;\n\n    //sprite already has calculated the vertices. lets transfer them to quad\n\n    var vertices = quad.vertices;\n    var vd = sprite.computedGeometry ? sprite.computedGeometry.vertices : sprite.vertexData;\n    for (var i = 0; i < 8; i++) {\n        quad.vertices[i] = vd[i];\n    }\n\n    //SpriteRenderer works differently, with uint32 UVS\n    //but for our demo float uvs are just fine\n    quad.uvs[0] = uvs.x0;\n    quad.uvs[1] = uvs.y0;\n    quad.uvs[2] = uvs.x1;\n    quad.uvs[3] = uvs.y1;\n    quad.uvs[4] = uvs.x2;\n    quad.uvs[5] = uvs.y2;\n    quad.uvs[6] = uvs.x3;\n    quad.uvs[7] = uvs.y3;\n\n    //TODO: add baricentric coords here\n    quad.upload();\n\n    var frame = sprite.texture.frame;\n    var base = sprite.texture.baseTexture;\n    var clamp = this._tempClamp;\n    //clamping 0.5 pixel from each side to reduce border artifact\n    //this is our plugin main purpose\n    clamp[0] = frame.x / base.width + 0.5 / base.realWidth;\n    clamp[1] = frame.y / base.height + 0.5 / base.realWidth;\n    clamp[2] = (frame.x + frame.width) / base.width - 0.5 / base.realWidth;\n    clamp[3] = (frame.y + frame.height) / base.height - 0.5 / base.realWidth;\n    //take a notice that size in pixels is realWidth,realHeight\n    //width and height are divided by resolution\n    shader.uniforms.uTextureClamp = clamp;\n\n    var color = this._tempColor;\n    PIXI.utils.hex2rgb(sprite.tint, color);\n    var alpha = sprite.worldAlpha;\n    //premultiplied alpha tint\n    //of course we could do that in shader too\n    color[0] *= alpha;\n    color[1] *= alpha;\n    color[2] *= alpha;\n    color[3] = alpha;\n    shader.uniforms.uColor = color;\n\n    //bind texture to unit 0, our default sampler unit\n    renderer.bindTexture(base, 0);\n    quad.draw();\n};\n\nPIXI.WebGLRenderer.registerPlugin('picture', PictureRenderer);\n\nmodule.exports = PictureRenderer;\n","\n\n/**\n * @class\n * @extends PIXI.Shader\n * @memberof PIXI.extras\n * @param gl {PIXI.Shader} The WebGL shader manager this shader works for.\n */\nfunction PictureShader(gl)\n{\n    PIXI.Shader.call(this,\n        gl,\n        \"#define GLSLIFY 1\\nattribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\nattribute vec4 aColor;\\n\\nuniform mat3 projectionMatrix;\\n\\nvarying vec2 vTextureCoord;\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n    vTextureCoord = aTextureCoord;\\n}\\n\",\n        \"#define GLSLIFY 1\\nvarying vec2 vTextureCoord;\\nvarying vec4 vColor;\\n\\nuniform sampler2D uSampler;\\nuniform vec4 uTextureClamp;\\nuniform vec4 uColor;\\n\\nvoid main(void)\\n{\\n    vec2 textureCoord = clamp(vTextureCoord, uTextureClamp.xy, uTextureClamp.zw);\\n    vec4 sample = texture2D(uSampler, textureCoord);\\n    gl_FragColor = sample * uColor;\\n}\\n\"\n    );\n    //do some stuff, like default values for shader\n    //dont forget to bind it if you really are changing the uniforms\n    this.bind();\n    //default tint\n    //Its an example, actually PictureRenderer takes care of this stuff\n    this.uniforms.uColor = new Float32Array(1,1,1,1);\n}\n\nPictureShader.prototype = Object.create(PIXI.Shader.prototype);\nPictureShader.prototype.constructor = PictureShader;\nmodule.exports = PictureShader;\n","/**\n * A Sprite with reduced border artifacts\n *\n * @class\n * @extends PIXI.Sprite\n * @memberof PIXI.tilemap\n * @param texture {PIXI.Texture} the texture for this sprite\n */\nfunction PictureSprite(texture)\n{\n    PIXI.Sprite.call(this, texture);\n}\n\nPictureSprite.prototype = Object.create(PIXI.Sprite.prototype);\nPictureSprite.prototype.constructor = PictureSprite;\nmodule.exports = PictureSprite;\n\n/**\n * Renders the object using the WebGL renderer\n *\n * @param renderer {PIXI.WebGLRenderer}\n * @private\n */\nPictureSprite.prototype._renderWebGL = function (renderer)\n{\n    if (this.updateGeometry) {\n        this.updateGeometry();\n    }\n\n    //use different plugin for rendering\n    renderer.setObjectRenderer(renderer.plugins.picture);\n    renderer.plugins.picture.render(this);\n};\n","\n\n/**\n * @class\n * @extends PIXI.Shader\n * @memberof PIXI.tilemap\n * @param gl {PIXI.Shader} The WebGL shader manager this shader works for.\n */\nfunction SoftLightShader(gl)\n{\n    PIXI.Shader.call(this,\n        gl,\n        \"#define GLSLIFY 1\\nattribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\nattribute vec4 aColor;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 mapMatrix;\\n\\nvarying vec2 vTextureCoord;\\nvarying vec2 vMapCoord;\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n    vMapCoord = (mapMatrix * vec3(aVertexPosition, 1.0)).xy;\\n    vTextureCoord = aTextureCoord;\\n}\\n\",\n        \"#define GLSLIFY 1\\nvarying vec2 vTextureCoord;\\nvarying vec2 vMapCoord;\\nvarying vec4 vColor;\\n\\nuniform sampler2D uSampler[2];\\nuniform vec4 uTextureClamp;\\nuniform vec4 uColor;\\n\\nvoid main(void)\\n{\\n    vec2 textureCoord = clamp(vTextureCoord, uTextureClamp.xy, uTextureClamp.zw);\\n    vec4 source = texture2D(uSampler[0], textureCoord);\\n    vec4 target = texture2D(uSampler[1], vMapCoord);\\n\\n    vec3 multiply = Cb * Cs * 2.0 + Cs * Cs * (1.0 - 2.0 * Cb);\\n    vec3 screen = sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend);\\n    vec3 B;\\n\\n    if (Cb.r <= 0.5) {\\n        B.r = multiply.r;\\n    } else {\\n        B.r = screen.r;\\n    }\\n    if (Cb.g <= 0.5) {\\n        B.g = multiply.g;\\n    } else {\\n        B.g = screen.g;\\n    }\\n    if (Cb.b <= 0.5) {\\n        B.b = multiply.b;\\n    } else {\\n        B.b = screen.b;\\n    }\\n\\n    vec4 res;\\n\\n    res.xyz = (1.0 - source.a) * Cs + source.a * B;\\n    res.a = source.a + target.a * (1.0-source.a);\\n    gl_FragColor = vec4(res.xyz * res.a, res.a);\\n}\\n\"\n    );\n    this.bind();\n    this.uniforms.uSampler = [0, 1];\n}\n\nSoftLightShader.prototype = Object.create(PIXI.Shader.prototype);\nSoftLightShader.prototype.constructor = SoftLightShader;\nmodule.exports = SoftLightShader;\n","var CONST = PIXI,\n    OverlayShader = require('./OverlayShader'),\n    HardLightShader = require('./HardLightShader');\n    SoftLightShader = require('./SoftLightShader');\n\n/**\n * Maps gl blend combinations to WebGL\n * @class\n * @memberof PIXI\n */\nfunction mapFilterBlendModesToPixi(gl, array)\n{\n    array = array || [];\n\n    //TODO - premultiply alpha would be different.\n    //add a boolean for that!\n    array[CONST.BLEND_MODES.OVERLAY] = new OverlayShader(gl);\n    array[CONST.BLEND_MODES.HARD_LIGHT] = new HardLightShader(gl);\n    array[CONST.BLEND_MODES.SOFT_LIGHT] = new SoftLightShader(gl);\n\n    return array;\n}\n\nmodule.exports = mapFilterBlendModesToPixi;\n","var myPlugin = {\n    PictureSprite: require('./PictureSprite'),\n    PictureRenderer: require('./PictureRenderer')\n};\n\n//dump everything into extras\n\nObject.assign(PIXI.extras, myPlugin);\n\nmodule.exports = myPlugin;\n"],"sourceRoot":"/source/"}