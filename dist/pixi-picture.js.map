{"version":3,"file":"pixi-picture.js","sources":["../src/BlendFilter.ts","../src/FlipYFilter.ts","../src/MaskFilter.ts","../src/ShaderParts.ts","../src/Sprite.ts","../src/TilingSprite.ts","../src/FilterSystemMixin.ts","../src/index.ts"],"sourcesContent":["import { Filter } from '@pixi/core';\r\n\r\n/**\r\n * This filter uses a backdrop texture to calculate the output colors.\r\n *\r\n * A backdrop filter can use existing colors in the destination framebuffer to calculate the\r\n * output colors. It does not need to rely on in-built {@link PIXI.BLEND_MODES blend modes} to\r\n * do those calculations.\r\n */\r\nexport class BackdropFilter extends Filter\r\n{\r\n    /**\r\n     * The name of the {@link Filter.uniforms uniform} for the backdrop texture.\r\n     *\r\n     * @pixi/picture's does some mixin magic to bind a copy of destination framebuffer to\r\n     * this uniform.\r\n     */\r\n    backdropUniformName: string = null;\r\n\r\n    trivial = false;\r\n    /** @ignore */\r\n    _backdropActive = false;\r\n\r\n    /** If non-null, @pixi/picture will clear the filter's output framebuffer with this RGBA color. */\r\n    clearColor: Float32Array = null;\r\n}\r\n\r\n/** A shader part for blending source and destination colors. */\r\nexport interface IBlendShaderParts\r\n{\r\n    /**\r\n     * (optional) Code that declares any additional uniforms to be accepted by the {@link BlendFilter}.\r\n     *\r\n     * If you do use this, make sure these uniforms are passed in {@link IBlendShaderParts.uniforms uniforms}.\r\n     */\r\n    uniformCode?: string;\r\n\r\n    /**\r\n     * (optional) Uniforms to pass to the resulting {@link BlendFilter}.\r\n     *\r\n     * Make sure to declare these in {@link IBlendShaderParts.uniformCode uniformCode}.\r\n     */\r\n    uniforms?: { [key: string]: any };\r\n\r\n    /**\r\n     * The blend code that calculates the output color. The following variables are available to\r\n     * this code:\r\n     *\r\n     * | Variable | Type     | Description (colors are usually PMA)       |\r\n     * |----------|----------|--------------------------------------------|\r\n     * | b_src    | vec4     | Source color                               |\r\n     * | b_dst    | vec4     | Destination color                          |\r\n     * | b_res    | vec4     | Output / result color                      |\r\n     */\r\n    blendCode: string;\r\n}\r\n\r\nconst filterFrag = `\r\nvarying vec2 vTextureCoord;\r\n\r\nuniform sampler2D uSampler;\r\nuniform sampler2D uBackdrop;\r\nuniform vec2 uBackdrop_flipY;\r\n\r\n%UNIFORM_CODE%\r\n\r\nvoid main(void)\r\n{\r\n   vec2 backdropCoord = vec2(vTextureCoord.x, uBackdrop_flipY.x + uBackdrop_flipY.y * vTextureCoord.y);\r\n   vec4 b_src = texture2D(uSampler, vTextureCoord);\r\n   vec4 b_dest = texture2D(uBackdrop, backdropCoord);\r\n   vec4 b_res = b_dest;\r\n   \r\n   %BLEND_CODE%\r\n\r\n   gl_FragColor = b_res;\r\n}`;\r\n\r\n/**\r\n * A blend filter is a special kind of {@link BackdropFilter} that is used to implement additional blend modes.\r\n *\r\n * The blend filter takes in a {@link IBlendShaderParts} and integrates that code in its shader template to\r\n * blend the source and destination colors.\r\n *\r\n * The backdrop texture uniform for blend filters is {@code \"uBackdrop\"}.\r\n */\r\nexport class BlendFilter extends BackdropFilter\r\n{\r\n    /** @param shaderParts - The blending code shader part. */\r\n    constructor(shaderParts: IBlendShaderParts)\r\n    {\r\n        let fragCode = filterFrag;\r\n\r\n        fragCode = fragCode.replace('%UNIFORM_CODE%', shaderParts.uniformCode || '');\r\n        fragCode = fragCode.replace('%BLEND_CODE%', shaderParts.blendCode || '');\r\n\r\n        super(undefined, fragCode, shaderParts.uniforms);\r\n\r\n        this.backdropUniformName = 'uBackdrop';\r\n    }\r\n}\r\n","import { Filter } from '@pixi/core';\r\nimport type { Dict } from '@pixi/utils';\r\n\r\nconst vert = `\r\nattribute vec2 aVertexPosition;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nuniform vec4 inputSize;\r\nuniform vec4 outputFrame;\r\nuniform vec2 flipY;\r\n\r\nvec4 filterVertexPosition( void )\r\n{\r\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\r\n\r\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\r\n}\r\n\r\nvec2 filterTextureCoord( void )\r\n{\r\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\r\n}\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = filterVertexPosition();\r\n    vTextureCoord = filterTextureCoord();\r\n    vTextureCoord.y = flipY.x + flipY.y * vTextureCoord.y;\r\n}\r\n\r\n`;\r\n\r\nexport class FlipYFilter extends Filter\n{\r\n    constructor(frag?: string, uniforms?: Dict<any>)\n    {\r\n        const uni = uniforms || {};\r\n\n        if (!uni.flipY)\n        {\r\n            uni.flipY = new Float32Array([0.0, 1.0]);\r\n        }\r\n        super(vert, frag, uni);\r\n    }\r\n}\r\n","import { FilterSystem, RenderTexture, Filter, BLEND_MODES, CLEAR_MODES } from '@pixi/core';\r\nimport { BlendFilter } from './BlendFilter';\r\nimport { FlipYFilter } from './FlipYFilter';\r\n\r\n/**\r\n * The RGBA channel for {@link MaskFilter} to use to detect the mask region.\r\n *\r\n * When applying a {@link MaskFilter} to a mask {@link DisplayObject}, the object should render\r\n * into that channel. For example, if using the alpha channel - the mask should render with alpha\r\n * 1.0 where-ever the mask region is.\r\n *\r\n * @property {number} RED\r\n * @property {number} GREEN\r\n * @property {number} BLUE\r\n * @property {number} ALPHA\r\n */\r\nexport enum MASK_CHANNEL\r\n    {\r\n    RED = 0,\r\n    GREEN,\r\n    BLUE,\r\n    ALPHA\r\n}\r\n\r\n/** The mask configuration for {@link MaskFilter}. */\r\nexport class MaskConfig\r\n{\r\n    /**\r\n     * @param maskBefore - If true, {@link MaskFilter} will mask the input of the applied filter instead of\r\n     * \tthe output. In the case of a blur filter, this would cause cause the boundaries of the mask to soften\r\n     * \tas the blur would apply to the masked region instead of being clipped into it.\r\n     * @param channel - The mask channel indicating which pixels are in the mask region.\r\n     */\r\n    constructor(public maskBefore = false, channel: MASK_CHANNEL = MASK_CHANNEL.ALPHA)\r\n    {\r\n        this.uniforms.uChannel[channel] = 1.0;\r\n    }\r\n\r\n    /** @ignore */\r\n    uniformCode = 'uniform vec4 uChannel;';\r\n    /** @ignore */\r\n    uniforms: any = {\r\n        uChannel: new Float32Array([0, 0, 0, 0]), // shared uniform for all those shaders? ok, just set it before apply\r\n    };\r\n    /** @ignore */\r\n    blendCode = `b_res = dot(b_src, uChannel) * b_dest;`;\r\n\r\n    /**\r\n     * Flag that indicates the applied filter is Y-symmetric.\r\n     *\r\n     * {@link MaskFilter} will optimize rendering by not flipping the screen backdrop before passing it to the\r\n     * blend filter for Y-symmetric filters.\r\n     *\r\n     * A filter is Y-symmetric if giving it an inverted input and then inverting the output is equivalent\r\n     * to giving it an upright input.\r\n     */\r\n    safeFlipY = false;\r\n}\r\n\r\nconst tmpArray = new Float32Array([0, 1]);\r\n\r\n/**\r\n * A higher-order filter that applies the output of a filter to a masked region of the destination framebuffer.\r\n *\r\n * The masked region is defined by where-ever the target {@link DisplayObject} renders to in the world. For\r\n * example, if you draw a rectangle in the world and apply a masked-blur filter, the blur filter will apply\r\n * to pixels in the backdrop within the rectangle. The {@link DisplayObject} must render by drawing\r\n * a solid RGBA channel (see {@link MaskConfig}'s constructor).\r\n */\r\nexport class MaskFilter extends BlendFilter\r\n{\r\n    /**\r\n     * @param baseFilter - The filter being applied.\r\n     * @param config - The configuration for the mask.\r\n     */\r\n    constructor(public baseFilter: Filter, public config: MaskConfig = new MaskConfig())\r\n    {\r\n        super(config);\r\n        this.padding = baseFilter.padding;\r\n        this.safeFlipY = config.safeFlipY;\r\n    }\r\n\r\n    /** @ignore */\r\n    static _flipYFilter: FlipYFilter = null;\r\n\r\n    /**\r\n     * if base filter is not sensitive to flipping Y axis, you can turn this ON and save a temporary texture bind / drawcall\r\n     */\r\n    safeFlipY: boolean;\r\n\r\n    apply(filterManager: FilterSystem, input: RenderTexture, output: RenderTexture,\r\n        clearMode: CLEAR_MODES): void\r\n    {\r\n        const target = filterManager.getFilterTexture(input);\r\n\r\n        if (this.config.maskBefore)\r\n        {\r\n            const { blendMode } = this.state;\r\n\r\n            this.state.blendMode = BLEND_MODES.NONE;\r\n            filterManager.applyFilter(this, input, target, CLEAR_MODES.YES);\r\n            this.baseFilter.blendMode = blendMode;\r\n            this.baseFilter.apply(filterManager, target, output, clearMode);\r\n            this.state.blendMode = blendMode;\r\n        }\r\n        else\r\n        {\r\n            const { uBackdrop, uBackdrop_flipY } = this.uniforms;\r\n\r\n            if (uBackdrop_flipY[1] > 0 || this.safeFlipY)\r\n            {\r\n                this.baseFilter.apply(filterManager, uBackdrop, target, CLEAR_MODES.YES);\r\n            }\r\n            else\r\n            {\r\n                // in case there was a flip and base filter is not flipY-safe, we have to use extra flip operation\r\n                const targetFlip = filterManager.getFilterTexture(input);\r\n\r\n                if (!MaskFilter._flipYFilter)\r\n                {\r\n                    MaskFilter._flipYFilter = new FlipYFilter();\r\n                }\r\n                MaskFilter._flipYFilter.uniforms.flipY[0] = uBackdrop_flipY[0];\r\n                MaskFilter._flipYFilter.uniforms.flipY[1] = uBackdrop_flipY[1];\r\n                MaskFilter._flipYFilter.apply(filterManager, uBackdrop, targetFlip, CLEAR_MODES.YES);\r\n                this.baseFilter.apply(filterManager, targetFlip, target, CLEAR_MODES.YES);\r\n                filterManager.returnFilterTexture(targetFlip);\r\n                this.uniforms.uBackdrop_flipY = tmpArray;\r\n            }\r\n            this.uniforms.uBackdrop = target;\r\n            filterManager.applyFilter(this, input, output, clearMode);\r\n            this.uniforms.uBackdrop = uBackdrop;\r\n            this.uniforms.uBackdrop_flipY = uBackdrop_flipY;\r\n        }\r\n        filterManager.returnFilterTexture(target);\r\n    }\r\n}\r\n","import { BlendFilter, IBlendShaderParts } from './BlendFilter';\r\nimport { BLEND_MODES, Filter } from '@pixi/core';\r\n\r\ninterface IBlendModeShaderParts extends IBlendShaderParts\r\n{\r\n    npmBlendCode?: string\r\n}\r\n\r\nexport const BLEND_OPACITY\r\n    = `if (b_src.a == 0.0) {\r\n  gl_FragColor = vec4(0, 0, 0, 0);\r\n  return;\r\n}\r\nif (b_dest.a == 0.0) {\r\n  gl_FragColor = b_src;\r\n  return;\r\n}\r\nvec3 base = b_dest.rgb / b_dest.a;\r\nvec3 blend = b_src.rgb / b_src.a;\r\n%NPM_BLEND%\r\n// SWAP SRC WITH NPM BLEND\r\nvec3 new_src = (1.0 - b_dest.a) * blend + b_dest.a * B;\r\n// PORTER DUFF PMA COMPOSITION MODE\r\nb_res.a = b_src.a + b_dest.a * (1.0-b_src.a);\r\nb_res.rgb = b_src.a * new_src + (1.0 - b_src.a) * b_dest.rgb;\r\n`;\r\n\r\nexport const MULTIPLY_PART: IBlendModeShaderParts = {\r\n    blendCode: BLEND_OPACITY,\r\n    npmBlendCode: `vec3 B = blend * base;`\r\n};\r\n\r\n// reverse hardlight\r\nexport const OVERLAY_PART: IBlendModeShaderParts = {\r\n    blendCode: BLEND_OPACITY,\r\n    npmBlendCode: `vec3 B = blendOverlay(base, blend);`,\r\n    uniformCode: `\r\nfloat finalBlendOverlay(float base, float blend) \r\n{\r\n    return mix((1.0-2.0*(1.0-base)*(1.0-blend)), (2.0*base*blend), step(base, 0.5));\r\n}\r\n\r\nvec3 blendOverlay(vec3 base, vec3 blend) \r\n{\r\n    return vec3(\r\n        finalBlendOverlay(base.r,blend.r),\r\n        finalBlendOverlay(base.g,blend.g),\r\n        finalBlendOverlay(base.b,blend.b)\r\n    );\r\n}\r\n`,\r\n};\r\n\r\nexport const HARDLIGHT_PART: IBlendModeShaderParts = {\r\n    blendCode: BLEND_OPACITY,\r\n    npmBlendCode: `vec3 B = blendHardLightVec3(base, blend);`,\r\n    uniformCode: `\r\nfloat blendHardLight(float base, float blend)\r\n{\r\n    return mix((1.0-2.0*(1.0-base)*(1.0-blend)), 2.0*base*blend, 1.0 - step(blend, 0.5));\r\n}\r\n\r\nvec3 blendHardLightVec3(vec3 base, vec3 blend) \r\n{\r\n    return vec3(blendHardLight(base.r,blend.r),blendHardLight(base.g,blend.g),blendHardLight(base.b,blend.b));\r\n}`,\r\n};\r\n\r\nexport const SOFTLIGHT_PART: IBlendModeShaderParts = {\r\n    blendCode: BLEND_OPACITY,\r\n    npmBlendCode: `vec3 B = blendSoftLightVec3(blend, base);`,\r\n    uniformCode: `\r\nfloat blendSoftLight(float base, float blend)\r\n{\r\n    if(blend < 0.5)\r\n    {\r\n        return 2.0*base*blend+base*base*(1.0-2.0*blend);\r\n    }\r\n    else\r\n    {\r\n        return sqrt(base)*(2.0*blend-1.0)+2.0*base*(1.0-blend);\r\n    }\r\n}\r\n\r\nvec3 blendSoftLightVec3(vec3 base, vec3 blend)\r\n{\r\n    return vec3(blendSoftLight(base.r,blend.r),blendSoftLight(base.g,blend.g),blendSoftLight(base.b,blend.b));\r\n}\r\n`,\r\n};\r\n\r\nexport const DARKEN_PART: IBlendModeShaderParts = {\r\n    blendCode: BLEND_OPACITY,\r\n    npmBlendCode: `vec3 B = blendDarkenVec3(blend, base);`,\r\n    uniformCode: `\r\nfloat blendDarken(float base, float blend)\r\n{\r\n    return min(blend,base);\r\n}\r\n\r\nvec3 blendDarkenVec3(vec3 base, vec3 blend)\r\n{\r\n    return vec3(blendDarken(base.r,blend.r),blendDarken(base.g,blend.g),blendDarken(base.b,blend.b));\r\n}\r\n`,\r\n};\r\n\r\nexport const LIGHTEN_PART: IBlendModeShaderParts = {\r\n    blendCode: BLEND_OPACITY,\r\n    npmBlendCode: `vec3 B = blendLightenVec3(blend, base);`,\r\n    uniformCode: `\r\nfloat blendLighten(float base, float blend)\r\n{\r\n    return max(blend,base);\r\n}\r\n\r\nvec3 blendLightenVec3(vec3 base, vec3 blend)\r\n{\r\n    return vec3(blendLighten(base.r,blend.r),blendLighten(base.g,blend.g),blendLighten(base.b,blend.b));\r\n}\r\n`,\r\n};\r\n\r\nexport const COLOR_DODGE_PART: IBlendModeShaderParts = {\r\n    blendCode: BLEND_OPACITY,\r\n    npmBlendCode: `vec3 B = blendColorDodge(blend, base);`,\r\n    uniformCode: `\r\nfloat blendColorDodge(float base, float blend) {\r\n    return (blend==1.0)?blend:min(base/(1.0-blend),1.0);\r\n}\r\n\r\nvec3 blendColorDodge(vec3 base, vec3 blend) {\r\n    return vec3(blendColorDodge(base.r,blend.r),blendColorDodge(base.g,blend.g),blendColorDodge(base.b,blend.b));\r\n}\r\n`,\r\n};\r\n\r\nexport const COLOR_BURN_PART: IBlendModeShaderParts = {\r\n    blendCode: BLEND_OPACITY,\r\n    npmBlendCode: `vec3 B = blendColorBurn(blend, base);`,\r\n    uniformCode: `\r\nfloat colorBurn(float base, float blend)\r\n{\r\n    return max((1.0-((1.0-base)/blend)),0.0);\r\n}\r\n\r\nvec3 blendColorBurn(vec3 base, vec3 blend)\r\n{\r\n    return vec3(colorBurn(base.r,blend.r),colorBurn(base.g,blend.g),colorBurn(base.b,blend.b));\r\n}\r\n`,\r\n};\r\n\r\n/**\r\n * Maps {@link PIXI.BLEND_MODES blend modes} to {@link IBlendShaderParts.blendCode blend code}.\r\n *\r\n * This library provides blending code for {@link BLEND_MODES.MULTIPLY}, {@link BLEND_MODES.OVERLAY},\r\n * {@link BLEND_MODES.HARD_LIGHT}, {@link BLEND_MODES.SOFT_LIGHT}. If you add blend modes to the\r\n * {@link PIXI.BLEND_MODES} enumeration, you can implement them by augmenting this map with your shader\r\n * code.\r\n *\r\n * @type {object<string, string>}\r\n */\r\nexport const blendPartsArray: Array<IBlendModeShaderParts> = [];\r\n\r\nblendPartsArray[BLEND_MODES.MULTIPLY] = MULTIPLY_PART;\r\nblendPartsArray[BLEND_MODES.OVERLAY] = OVERLAY_PART;\r\nblendPartsArray[BLEND_MODES.HARD_LIGHT] = HARDLIGHT_PART;\r\nblendPartsArray[BLEND_MODES.SOFT_LIGHT] = SOFTLIGHT_PART;\r\nblendPartsArray[BLEND_MODES.DARKEN] = DARKEN_PART;\r\nblendPartsArray[BLEND_MODES.LIGHTEN] = LIGHTEN_PART;\r\nblendPartsArray[BLEND_MODES.COLOR_DODGE] = COLOR_DODGE_PART;\r\nblendPartsArray[BLEND_MODES.COLOR_BURN] = COLOR_BURN_PART;\r\n\r\nfor (const key in blendPartsArray)\r\n{\r\n    const part = blendPartsArray[key];\r\n\r\n    if (part.npmBlendCode)\r\n    {\r\n        part.blendCode = part.blendCode.replace(`%NPM_BLEND%`, part.npmBlendCode);\r\n    }\r\n}\r\n\r\nconst filterCache: Array<BlendFilter> = [];\r\nconst filterCacheArray: Array<Array<BlendFilter>> = [];\r\nconst trivialBlend = new Array<boolean>(32);\r\n\r\ntrivialBlend[BLEND_MODES.NORMAL] = true;\r\ntrivialBlend[BLEND_MODES.ADD] = true;\r\ntrivialBlend[BLEND_MODES.SCREEN] = true;\r\ntrivialBlend[BLEND_MODES.DST_OUT] = true;\r\ntrivialBlend[BLEND_MODES.DST_IN] = true;\r\ntrivialBlend[BLEND_MODES.DST_OVER] = true;\r\ntrivialBlend[BLEND_MODES.DST_ATOP] = true;\r\ntrivialBlend[BLEND_MODES.SRC_OUT] = true;\r\ntrivialBlend[BLEND_MODES.SRC_IN] = true;\r\ntrivialBlend[BLEND_MODES.SRC_OVER] = true;\r\ntrivialBlend[BLEND_MODES.SRC_ATOP] = true;\r\ntrivialBlend[BLEND_MODES.SRC_OUT] = true;\r\ntrivialBlend[BLEND_MODES.SRC_IN] = true;\r\ntrivialBlend[BLEND_MODES.SRC_OVER] = true;\r\ntrivialBlend[BLEND_MODES.XOR] = true;\r\ntrivialBlend[BLEND_MODES.SUBTRACT] = true;\r\n\r\n/**\r\n * Get a memoized {@link BlendFilter} for the passed blend mode. This expects {@link blendFullArray}\r\n * to have the blending code beforehand.\r\n *\r\n * If you changed the blending code in {@link blendFullArray}, this won't create a new blend filter\r\n * due to memoization!\r\n *\r\n * @param blendMode - The blend mode desired.\r\n */\r\nexport function getBlendFilter(blendMode: BLEND_MODES)\r\n{\r\n    const triv = trivialBlend[blendMode];\r\n\r\n    if (!triv && !blendPartsArray[blendMode])\r\n    {\r\n        return null;\r\n    }\r\n    if (!filterCache[blendMode])\r\n    {\r\n        if (triv)\r\n        {\r\n            filterCache[blendMode] = (new Filter()) as any;\r\n            filterCache[blendMode].blendMode = blendMode;\r\n            filterCache[blendMode].trivial = true;\r\n        }\r\n        else\r\n        {\r\n            filterCache[blendMode] = new BlendFilter(blendPartsArray[blendMode]);\r\n        }\r\n    }\r\n\r\n    return filterCache[blendMode];\r\n}\r\n\r\n/**\r\n * Similar to {@link getBlendFilter}, but wraps the filter in a memoized array.\r\n *\r\n * This is useful when assigning {@link PIXI.Container.filters} as a new array will not be created\r\n * per re-assigment.\r\n *\r\n * ```\r\n * import { getBlendFilter, getBlendFilterArray } from '@pixi/picture';\r\n *\r\n * // Don't do\r\n * displayObject.filters = [getBlendFilter(BLEND_MODES.OVERLAY)];\r\n *\r\n * // Do\r\n * displayObject.filters = getBlendFilterArray(BLEND_MODES.OVERLAY);\r\n * ```\r\n *\r\n * @param blendMode - The blend mode desired.\r\n */\r\nexport function getBlendFilterArray(blendMode: BLEND_MODES)\r\n{\r\n    if (!blendPartsArray[blendMode])\r\n    {\r\n        return null;\r\n    }\r\n    if (!filterCacheArray[blendMode])\r\n    {\r\n        filterCacheArray[blendMode] = [getBlendFilter(blendMode)];\r\n    }\r\n\r\n    return filterCacheArray[blendMode];\r\n}\r\n","import { Sprite as SpriteBase } from '@pixi/sprite';\r\nimport { Renderer, BLEND_MODES } from '@pixi/core';\r\nimport { getBlendFilterArray } from './ShaderParts';\r\nimport { IPictureFilterSystem } from './FilterSystemMixin';\r\n\r\nexport class Sprite extends SpriteBase\r\n{\r\n    _render(renderer: Renderer): void\r\n    {\r\n        const texture = (this as any)._texture;\r\n\r\n        if (!texture || !texture.valid)\r\n        {\r\n            return;\r\n        }\r\n\r\n        const blendFilterArray = getBlendFilterArray(this.blendMode);\r\n        const cacheBlend = this.blendMode;\r\n\r\n        if (blendFilterArray)\r\n        {\r\n            renderer.batch.flush();\r\n            if (!(renderer.filter as IPictureFilterSystem).pushWithCheck(this, blendFilterArray))\r\n            {\r\n                return;\r\n            }\r\n            this.blendMode = BLEND_MODES.NORMAL;\r\n        }\r\n\r\n        this.calculateVertices();\r\n        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);\r\n        renderer.plugins[this.pluginName].render(this);\r\n\r\n        if (blendFilterArray)\r\n        {\r\n            renderer.batch.flush();\r\n            renderer.filter.pop();\r\n            this.blendMode = cacheBlend;\r\n        }\r\n    }\r\n}\r\n","import { TilingSprite as TilingSpriteBase } from '@pixi/sprite-tiling';\r\nimport { Renderer } from '@pixi/core';\r\nimport { getBlendFilterArray } from './ShaderParts';\r\nimport { IPictureFilterSystem } from './FilterSystemMixin';\r\n\r\nexport class TilingSprite extends TilingSpriteBase\n{\r\n    _render(renderer: Renderer): void\r\n    {\r\n        // tweak our texture temporarily..\r\n        const texture = (this as any)._texture;\r\n\r\n        if (!texture || !texture.valid)\r\n        {\r\n            return;\r\n        }\r\n\r\n        const blendFilterArray = getBlendFilterArray(this.blendMode);\r\n\r\n        if (blendFilterArray)\n        {\r\n            renderer.batch.flush();\r\n            if (!(renderer.filter as any as IPictureFilterSystem).pushWithCheck(this, blendFilterArray))\n            {\r\n                return;\r\n            }\r\n        }\r\n\r\n        this.tileTransform.updateLocalTransform();\r\n        this.uvMatrix.update();\r\n\r\n        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);\r\n        renderer.plugins[this.pluginName].render(this);\r\n\r\n        if (blendFilterArray)\n        {\r\n            renderer.batch.flush();\r\n            renderer.filter.pop();\r\n        }\r\n    }\r\n}\r\n","import {\r\n    TextureSystem,\r\n    FilterSystem,\r\n    BaseTexture,\r\n    RenderTexture,\r\n    Filter,\r\n    FilterState,\r\n    CLEAR_MODES,\r\n    State\r\n} from '@pixi/core';\r\nimport { Matrix, Rectangle } from '@pixi/math';\r\nimport { DisplayObject } from '@pixi/display';\r\nimport { BackdropFilter } from './BlendFilter';\r\n\r\nexport interface IPictureFilterSystem extends FilterSystem\r\n{\r\n    prepareBackdrop(sourceFrame: Rectangle, flipY: Float32Array): RenderTexture;\r\n\r\n    pushWithCheck(target: DisplayObject, filters: Array<Filter>, checkEmptyBounds?: boolean): boolean;\r\n}\r\n\r\nexport interface IPictureTextureSystem extends TextureSystem\r\n{\r\n    bindForceLocation(texture: BaseTexture, location: number): void;\r\n}\r\n\r\nfunction containsRect(rectOut: Rectangle, rectIn: Rectangle): boolean\r\n{\r\n    const r1 = rectIn.x + rectIn.width;\r\n    const b1 = rectIn.y + rectIn.height;\r\n    const r2 = rectOut.x + rectOut.width;\r\n    const b2 = rectOut.y + rectOut.height;\r\n\r\n    return (rectIn.x >= rectOut.x)\r\n        && (rectIn.x <= r2)\r\n        && (rectIn.y >= rectOut.y)\r\n        && (rectIn.y <= b2)\r\n        && (r1 >= rectOut.x)\r\n        && (r1 <= r2)\r\n        && (b1 >= rectOut.y)\r\n        && (b1 <= b2);\r\n}\r\n\r\nfunction bindForceLocation(this: IPictureTextureSystem, texture: BaseTexture, location = 0)\r\n{\r\n    const { gl } = this;\r\n\r\n    if (this.currentLocation !== location)\r\n    {\r\n        this.currentLocation = location;\r\n        gl.activeTexture(gl.TEXTURE0 + location);\r\n    }\r\n    this.bind(texture, location);\r\n}\r\n\r\nconst tempMatrix = new Matrix();\r\n\r\nfunction pushWithCheck(this: IPictureFilterSystem,\r\n    target: DisplayObject, filters: Array<BackdropFilter>, checkEmptyBounds = true)\r\n{\r\n    const renderer = this.renderer;\r\n    const filterStack = this.defaultFilterStack;\r\n    const state = this.statePool.pop() || new FilterState();\r\n    const renderTextureSystem = this.renderer.renderTexture;\r\n\r\n    let resolution = filters[0].resolution;\r\n    let padding = filters[0].padding;\r\n    let autoFit = filters[0].autoFit;\r\n    let legacy = filters[0].legacy;\r\n\r\n    for (let i = 1; i < filters.length; i++)\r\n    {\r\n        const filter = filters[i];\r\n\r\n        resolution = Math.min(resolution, filter.resolution);\r\n        padding = this.useMaxPadding\r\n            ? Math.max(padding, filter.padding)\r\n            : padding + filter.padding;\r\n        autoFit = autoFit && filter.autoFit;\r\n\r\n        legacy = legacy || filter.legacy;\r\n    }\r\n\r\n    if (filterStack.length === 1)\r\n    {\r\n        this.defaultFilterStack[0].renderTexture = renderTextureSystem.current;\r\n    }\r\n\r\n    filterStack.push(state);\r\n\r\n    state.resolution = resolution;\r\n\r\n    state.legacy = legacy;\r\n\r\n    state.target = target;\r\n    state.sourceFrame.copyFrom(target.filterArea || target.getBounds(true));\r\n\r\n    state.sourceFrame.pad(padding);\r\n\r\n    let canUseBackdrop = true;\r\n\r\n    if (autoFit)\r\n    {\r\n        const sourceFrameProjected = (this as any).tempRect.copyFrom(renderTextureSystem.sourceFrame);\r\n\r\n        // Project source frame into world space (if projection is applied)\r\n        if (renderer.projection.transform)\r\n        {\r\n            (this as any).transformAABB(\r\n                tempMatrix.copyFrom(renderer.projection.transform).invert(),\r\n                sourceFrameProjected\r\n            );\r\n        }\r\n\r\n        state.sourceFrame.fit(sourceFrameProjected);\r\n    }\r\n    else\r\n    {\r\n        // check if backdrop is obtainable after rejecting autoFit\r\n        canUseBackdrop = containsRect(this.renderer.renderTexture.sourceFrame, state.sourceFrame);\r\n    }\r\n\r\n    if (checkEmptyBounds && state.sourceFrame.width <= 1 && state.sourceFrame.height <= 1)\r\n    {\r\n        filterStack.pop();\r\n        state.clear();\r\n        this.statePool.push(state);\r\n\r\n        return false;\r\n    }\r\n    (this as any).roundFrame(\r\n        state.sourceFrame,\r\n        renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution,\r\n        renderTextureSystem.sourceFrame,\r\n        renderTextureSystem.destinationFrame,\r\n        renderer.projection.transform,\r\n    );\r\n\r\n    // round to whole number based on resolution\r\n    state.sourceFrame.ceil(resolution);\r\n\r\n    // detect backdrop uniform\r\n    if (canUseBackdrop)\r\n    {\r\n        let backdrop = null;\r\n        let backdropFlip = null;\r\n\r\n        for (let i = 0; i < filters.length; i++)\r\n        {\r\n            const bName = filters[i].backdropUniformName;\r\n\r\n            if (bName)\r\n            {\r\n                const { uniforms } = filters[i];\r\n\r\n                if (!uniforms[`${bName}_flipY`])\r\n                {\r\n                    uniforms[`${bName}_flipY`] = new Float32Array([0.0, 1.0]);\r\n                }\r\n                const flip = uniforms[`${bName}_flipY`];\r\n\r\n                if (backdrop === null)\r\n                {\r\n                    backdrop = this.prepareBackdrop(state.sourceFrame, flip);\r\n                    backdropFlip = flip;\r\n                }\r\n                else\r\n                {\r\n                    flip[0] = backdropFlip[0];\r\n                    flip[1] = backdropFlip[1];\r\n                }\r\n\r\n                uniforms[bName] = backdrop;\r\n                if (backdrop)\r\n                {\r\n                    filters[i]._backdropActive = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (backdrop)\r\n        {\r\n            resolution = state.resolution = backdrop.resolution;\r\n        }\r\n    }\r\n\r\n    state.renderTexture = this.getOptimalFilterTexture(state.sourceFrame.width, state.sourceFrame.height, resolution);\r\n    state.filters = filters;\r\n\r\n    state.destinationFrame.width = state.renderTexture.width;\r\n    state.destinationFrame.height = state.renderTexture.height;\r\n\r\n    const destinationFrame = (this as any).tempRect;\r\n\r\n    destinationFrame.x = 0;\r\n    destinationFrame.y = 0;\r\n    destinationFrame.width = state.sourceFrame.width;\r\n    destinationFrame.height = state.sourceFrame.height;\r\n\r\n    state.renderTexture.filterFrame = state.sourceFrame;\r\n    state.bindingSourceFrame.copyFrom(renderTextureSystem.sourceFrame);\r\n    state.bindingDestinationFrame.copyFrom(renderTextureSystem.destinationFrame);\r\n\r\n    state.transform = renderer.projection.transform;\r\n    renderer.projection.transform = null;\r\n    renderTextureSystem.bind(state.renderTexture, state.sourceFrame, destinationFrame);\r\n\r\n    const cc = filters[filters.length - 1].clearColor as any;\r\n\r\n    if (cc)\r\n    {\r\n        // take clear color from filter, it helps for advanced DisplacementFilter\r\n        renderer.framebuffer.clear(cc[0], cc[1], cc[2], cc[3]);\r\n    }\r\n    else\r\n    {\r\n        renderer.framebuffer.clear(0, 0, 0, 0);\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nfunction push(this: IPictureFilterSystem,\r\n    target: DisplayObject, filters: Array<Filter>)\r\n{\r\n    return this.pushWithCheck(target, filters, false);\r\n}\r\n\r\nfunction pop(this: IPictureFilterSystem)\r\n{\r\n    const filterStack = this.defaultFilterStack;\r\n    const state = filterStack.pop();\r\n    const filters = state.filters as Array<BackdropFilter>;\r\n\r\n    this.activeState = state;\r\n\r\n    const globalUniforms = this.globalUniforms.uniforms;\r\n\r\n    globalUniforms.outputFrame = state.sourceFrame;\r\n    globalUniforms.resolution = state.resolution;\r\n\r\n    const inputSize = globalUniforms.inputSize;\r\n    const inputPixel = globalUniforms.inputPixel;\r\n    const inputClamp = globalUniforms.inputClamp;\r\n\r\n    inputSize[0] = state.destinationFrame.width;\r\n    inputSize[1] = state.destinationFrame.height;\r\n    inputSize[2] = 1.0 / inputSize[0];\r\n    inputSize[3] = 1.0 / inputSize[1];\r\n\r\n    inputPixel[0] = inputSize[0] * state.resolution;\r\n    inputPixel[1] = inputSize[1] * state.resolution;\r\n    inputPixel[2] = 1.0 / inputPixel[0];\r\n    inputPixel[3] = 1.0 / inputPixel[1];\r\n\r\n    inputClamp[0] = 0.5 * inputPixel[2];\r\n    inputClamp[1] = 0.5 * inputPixel[3];\r\n    inputClamp[2] = (state.sourceFrame.width * inputSize[2]) - (0.5 * inputPixel[2]);\r\n    inputClamp[3] = (state.sourceFrame.height * inputSize[3]) - (0.5 * inputPixel[3]);\r\n\r\n    // only update the rect if its legacy..\r\n    if (state.legacy)\r\n    {\r\n        const filterArea = globalUniforms.filterArea;\r\n\r\n        filterArea[0] = state.destinationFrame.width;\r\n        filterArea[1] = state.destinationFrame.height;\r\n        filterArea[2] = state.sourceFrame.x;\r\n        filterArea[3] = state.sourceFrame.y;\r\n\r\n        globalUniforms.filterClamp = globalUniforms.inputClamp;\r\n    }\r\n\r\n    this.globalUniforms.update();\r\n\r\n    const lastState = filterStack[filterStack.length - 1];\r\n\r\n    if (state.renderTexture.framebuffer.multisample > 1)\r\n    {\r\n        this.renderer.framebuffer.blit();\r\n    }\r\n\r\n    let filterLen = filters.length;\r\n    let tmpState: State = null;\r\n\r\n    if (filterLen >= 2 && filters[filterLen - 1].trivial)\r\n    {\r\n        tmpState = filters[filterLen - 2].state;\r\n        filters[filterLen - 2].state = filters[filterLen - 1].state;\r\n        filterLen--;\r\n    }\r\n\r\n    if (filterLen === 1)\r\n    {\r\n        filters[0].apply(this, state.renderTexture, lastState.renderTexture, CLEAR_MODES.BLEND, state);\r\n\r\n        this.returnFilterTexture(state.renderTexture);\r\n    }\r\n    else\r\n    {\r\n        let flip = state.renderTexture;\r\n        let flop = this.getOptimalFilterTexture(\r\n            flip.width,\r\n            flip.height,\r\n            state.resolution\r\n        );\r\n\r\n        flop.filterFrame = flip.filterFrame;\r\n\r\n        let i = 0;\r\n\r\n        for (i = 0; i < filterLen - 1; ++i)\r\n        {\r\n            filters[i].apply(this, flip, flop, CLEAR_MODES.CLEAR, state);\r\n\r\n            const t = flip;\r\n\r\n            flip = flop;\r\n            flop = t;\r\n        }\r\n\r\n        filters[i].apply(this, flip, lastState.renderTexture, CLEAR_MODES.BLEND, state);\r\n\r\n        this.returnFilterTexture(flip);\r\n        this.returnFilterTexture(flop);\r\n    }\r\n    if (tmpState)\r\n    {\r\n        filters[filterLen - 1].state = tmpState;\r\n    }\r\n\r\n    // release the backdrop!\r\n    let backdropFree = false;\r\n\r\n    for (let i = 0; i < filters.length; i++)\r\n    {\r\n        if (filters[i]._backdropActive)\r\n        {\r\n            const bName = filters[i].backdropUniformName;\r\n\r\n            if (!backdropFree)\r\n            {\r\n                this.returnFilterTexture(filters[i].uniforms[bName]);\r\n                backdropFree = true;\r\n            }\r\n            filters[i].uniforms[bName] = null;\r\n            filters[i]._backdropActive = false;\r\n        }\r\n    }\r\n\r\n    state.clear();\r\n    this.statePool.push(state);\r\n}\r\n\r\nlet hadBackbufferError = false;\r\n\r\n/**\r\n * Takes a part of current render target corresponding to bounds\r\n * fits sourceFrame to current render target frame to evade problems\r\n */\r\nfunction prepareBackdrop(bounds: Rectangle, flipY: Float32Array): RenderTexture\r\n{\r\n    const renderer = this.renderer;\r\n    const renderTarget = renderer.renderTexture.current;\r\n    const fr = this.renderer.renderTexture.sourceFrame;\r\n    const tf = renderer.projection.transform || Matrix.IDENTITY;\r\n\r\n    // TODO: take non-standart sourceFrame/destinationFrame into account, all according to ShukantPal refactoring\r\n\r\n    let resolution = 1;\r\n\r\n    if (renderTarget)\r\n    {\r\n        resolution = renderTarget.baseTexture.resolution;\r\n        flipY[1] = 1.0;\r\n    }\r\n    else\r\n    {\r\n        if (this.renderer.background.alpha >= 1)\r\n        {\r\n            if (!hadBackbufferError)\r\n            {\r\n                hadBackbufferError = true;\r\n                console.warn('pixi-picture: you are trying to use Blend Filter on main framebuffer!');\r\n                console.warn('pixi-picture: please set backgroundAlpha=0 in renderer creation params');\r\n            }\r\n\r\n            return null;\r\n        }\r\n        resolution = renderer.resolution;\r\n        flipY[1] = -1.0;\r\n    }\r\n\r\n    // bounds.fit(fr);\r\n\r\n    const x = Math.round((bounds.x - fr.x + tf.tx) * resolution);\r\n    const dy = bounds.y - fr.y + tf.ty;\r\n    const y = Math.round((flipY[1] < 0.0 ? fr.height - (dy + bounds.height) : dy) * resolution);\r\n    const w = Math.round(bounds.width * resolution);\r\n    const h = Math.round(bounds.height * resolution);\r\n\r\n    const gl = renderer.gl;\r\n    const rt = this.getOptimalFilterTexture(w, h, 1);\r\n\r\n    if (flipY[1] < 0)\r\n    {\r\n        flipY[0] = h / rt.height;\r\n    }\r\n\r\n    rt.filterFrame = fr;\r\n    rt.setResolution(resolution);\r\n    renderer.texture.bindForceLocation(rt.baseTexture, 0);\r\n    gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, x, y, w, h);\r\n\r\n    return rt;\r\n}\r\n\r\nexport function applyMixins()\r\n{\r\n    (TextureSystem as any).prototype.bindForceLocation = bindForceLocation;\r\n    (FilterSystem as any).prototype.push = push;\r\n    (FilterSystem as any).prototype.pushWithCheck = pushWithCheck as any;\r\n    (FilterSystem as any).prototype.pop = pop;\r\n    (FilterSystem as any).prototype.prepareBackdrop = prepareBackdrop;\r\n}\r\n","export * from './BlendFilter';\r\nexport * from './FlipYFilter';\r\nexport * from './MaskFilter';\r\nexport * from './ShaderParts';\r\nexport * from './Sprite';\r\nexport * from './TilingSprite';\r\nexport * from './FilterSystemMixin';\r\nimport { applyMixins } from './FilterSystemMixin';\r\n\r\napplyMixins();\r\n"],"names":["BackdropFilter","Filter","filterFrag","BlendFilter","shaderParts","fragCode","vert","FlipYFilter","frag","uniforms","uni","MASK_CHANNEL","i","MaskConfig","maskBefore","channel","tmpArray","_MaskFilter","baseFilter","config","filterManager","input","output","clearMode","target","blendMode","BLEND_MODES","CLEAR_MODES","uBackdrop","uBackdrop_flipY","targetFlip","MaskFilter","BLEND_OPACITY","MULTIPLY_PART","OVERLAY_PART","HARDLIGHT_PART","SOFTLIGHT_PART","DARKEN_PART","LIGHTEN_PART","COLOR_DODGE_PART","COLOR_BURN_PART","blendPartsArray","key","part","filterCache","filterCacheArray","trivialBlend","getBlendFilter","triv","getBlendFilterArray","Sprite","SpriteBase","renderer","texture","blendFilterArray","cacheBlend","TilingSprite","TilingSpriteBase","containsRect","rectOut","rectIn","r1","b1","r2","b2","bindForceLocation","location","gl","tempMatrix","Matrix","pushWithCheck","filters","checkEmptyBounds","filterStack","state","FilterState","renderTextureSystem","resolution","padding","autoFit","legacy","filter","canUseBackdrop","sourceFrameProjected","backdrop","backdropFlip","bName","flip","destinationFrame","cc","push","pop","globalUniforms","inputSize","inputPixel","inputClamp","filterArea","lastState","filterLen","tmpState","flop","t","backdropFree","hadBackbufferError","prepareBackdrop","bounds","flipY","renderTarget","fr","tf","x","dy","y","w","h","rt","applyMixins","TextureSystem","FilterSystem"],"mappings":"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"}